# The project
This project provides a GUI app to run the Gross-Pitaevskii equation for Bose-Einstein condensates.
It assumes a 3D harmonic potential. The user can select grid and potential parameters and even imprint vortices in real time.
For this to work, the assumption is that the BEC is confined in the z-axis leading to a disk-shaped 2D BEC.


SimParams Struct: Defines the data structure to hold configuration values, making it type-safe compared to the Python dictionary.

# How to Run
Simply run the .exe application. Then select the parameters in the pop-up window. Start and stop the simulation by clicking on the
respective buttons.

Note that since this only runs on CPU, if the grid is too big e.g. more than 256x256x16, it will take wuite some time for the simulation
and you'll be seeing it lagging.

# Code structure
## Simulation.go

PlotData:
    Time: Transmits the current simulation time for display.
    
    DensitySlice, PhaseSlice: Contain the actual 2D data arrays ([][]float64) for the density and phase plots. These are generated by the simulation's slicing functions.

    Extent: Provides the [xmin, xmax, ymin, ymax] values needed by the plotting logic to correctly map data indices to spatial coordinates on the plot axes.

    SliceAxis: Records which dimension ('x', 'y', or 'z') was sliced to produce this data. Currently used implicitly (always 'z'), but useful for future extensions.

    Error: A crucial field. If the simulation encounters an error (e.g., numerical instability, failure during a step), it can send a PlotData struct with this field set. The GUI update loop checks this field first and displays the error instead of attempting to plot potentially invalid data.

ControlMsg:

    Command: A string identifier for the action requested by the GUI (e.g., "start", "stop", "reset", "update_g", "imprint"). The simulation's handleControlMessage function uses a switch statement on this field.

    GValue: Used to send the updated value from the 'g' slider when the command is "update_g". It's also conveniently used by the reset button callback to tell the simulation what value 'g' should be reset to (matching the current slider position).

    Vortex: Embeds the VortexInfo struct (which contains X0, Y0, Charge) when the command is "imprint". This packages all necessary information for the vortex imprinting action.
    
GPE3DSimulation Struct:

    Contains all necessary fields: parameters (params), constants (hbar, m), calculated grid info (dx, dy, ...), grid arrays (x, y, z, kx, ..., psi, potentialV, expK), simulation state (time, dt, gVal, running, vortices), communication (updateChan, controlChan), and control (mu, ctx, cancel, wg).

    Arrays are declared as 3D slices ([][][]).

NewSimulation Constructor:

    Performs basic validation on input parameters.

    Initializes the struct fields with constants, defaults, and passed-in channels/parameters.

    Creates a context.WithCancel pair for managing the simulation lifecycle.

    Calls helper methods (createGrids, calculatePotential, initialState, precomputeExpK) to perform the bulk of the setup work.

    Makes a deepCopyPsi of the initial state to store for the reset functionality.

    Returns the fully initialized *GPE3DSimulation object or an error if setup failed.

createGrids Method:

    Calculates grid spacings (dx, dy, dz) and volume element (dv).

    Uses gonum/floats.Span to generate 1D coordinate arrays, adjusting the endpoint to match numpy.linspace(..., endpoint=False).

    Allocates memory for all 3D grid arrays (x, y, z, kx, ky, kz, kSq).

    Fills the real-space coordinate grids (x, y, z).

    Calculates the corresponding k-space vectors based on FFT frequency conventions and fills kx, ky, kz, and kSq.

calculatePotential Method:

    Allocates the potentialV array.

    Iterates through the grid points, calculating the harmonic potential value 0.5 * m * (ox^2*x^2 + ...) at each point using the pre-calculated coordinate grids (sim.x, sim.y, sim.z).

initialState Method:

    Calculates the anisotropic Gaussian widths (sigmaX, sigmaY, sigmaZ) based on the potential frequencies (omegaX, ...), handling the omega=0 case.

    Clamps the widths to be smaller than the box size.

    Allocates the psi0 array.

    Iterates through the grid, calculating the Gaussian value exp(-(x^2/(2*sx^2) + ...)) at each point.

    Calculates the normalization constant by summing |psi|^2 * dv over the grid.

    Normalizes the wavefunction by dividing each element by the calculated norm.

precomputeExpK Method:

    Allocates the expK array.

    Calculates the complex kinetic evolution factor exp(-0.5i * hbar/m * kSq * dt) for each point in k-space using the pre-calculated sim.kSq grid.


This file now contains the complete setup logic for the simulation state based on the user's configuration.
potentialStep:

    Takes psiIn as input and returns a new psiOut array.

    Reads gVal using a Read Lock (sim.mu.RLock()) as gVal might be written by the GUI goroutine concurrently.

    Calculates V_eff = V + g*|psi|^2.

    Calculates the evolution factor exp(-0.5i * V_eff * dt / hbar).

    Multiplies psiIn by the factor element-wise to get psiOut.

kineticStep:

    Takes psiIn, returns psiOut.

    Flattening: Uses flatten3DComplex to convert the 3D input psiIn to a 1D slice (psiFlat) suitable for fft.FFTN.

    FFT: Calls fft.FFTN(psiFlat) to get the k-space representation (psiKFlat).

    Apply Operator: Flattens the precomputed sim.expK. Multiplies psiKFlat element-wise by expKFlat.

    Inverse FFT: Calls fft.IFFTN on the result.

    Normalization: Divides the result of IFFTN by N (number of points) because fft.FFTN and fft.IFFTN are unnormalized.

    Unflattening: Uses unflatten3DComplex to convert the 1D result (psiOutFlat) back to a 3D array (psiOut).

    Includes basic error checking for flattening/unflattening steps.

step:

    Implements the Strang splitting formula: Potential(dt/2) * Kinetic(dt) * Potential(dt/2).

    Calls potentialStep, kineticStep, potentialStep sequentially, passing the output of one as the input to the next. Each step function returns a new array.

    Updates sim.psi with the final result.

    Includes an optional sanity check for NaN or Inf values in the wavefunction, which would indicate numerical instability. Stops the simulation if detected.

    Increments sim.time.

    Returns an error if any sub-step fails or instability is detected.

Run:

    The core loop of the simulation goroutine.

    Uses defer sim.wg.Done() and defer close(sim.updateChan) for cleanup.

    Uses a time.Ticker to regulate the loop frequency.

    The select statement concurrently waits for:

        Context cancellation (sim.ctx.Done()): Shuts down gracefully.

        Control messages (<-sim.controlChan): Calls handleControlMessage.

        Ticker ticks (<-simulationUpdateTicker.C): Proceeds to run simulation steps if sim.running is true.

    Running Steps:

        Acquires a Write Lock (sim.mu.Lock()) before running steps to ensure exclusive access to psi, time.

        Runs numStepsPerFrame simulation steps using sim.step(). Handles errors from step() by stopping the simulation and notifying the GUI.

        Makes a deep copy of sim.psi under the lock so the lock can be released before the potentially slower slicing/plotting operations.

        Releases the lock (sim.mu.Unlock()).

    Sending Updates:

        Calls slicing functions (to be implemented next) using the copied wavefunction data.

        Constructs a PlotData struct.

        Uses a non-blocking select to send the PlotData on sim.updateChan. If the channel is full (GUI is lagging), it logs a warning and drops the frame instead of blocking the simulation loop.

handleControlMessage:

    Contains the logic for reacting to start, stop, reset, update_g, and imprint commands.

    Modifies sim.running, sim.psi, sim.time, sim.gVal, sim.vortices as needed.

    For reset and imprint, it now follows a safer pattern: copy data under lock, release lock, prepare plot data from copy, send update asynchronously, re-acquire lock if needed (though not strictly necessary here as it's the end of the handler). This prevents deadlocks if slicing functions also need locks.

This completes the core simulation loop and step logic using the CPU and the chosen FFT library.

imprintVortex:

    Takes the vortex center coordinates (x0, y0) and charge as input.

    Iterates through the sim.psi grid.

    For each grid point (i, j, k), it calculates the position (x, y) using the precomputed sim.x, sim.y grids.

    Calculates the phase charge * atan2(x - x0, -(y - y0)).

    Computes the complex phase factor exp(i * phase).

    Multiplies the existing sim.psi[i][j][k] by this phaseFactor.

    This directly modifies the sim.psi array. It's intended to be called when the simulation is stopped and appropriately locked.

## Gui.go

AppUI Struct: Holds references to all necessary Fyne components (App, Window, Widgets) and communication channels (updateChan, controlChan). It also stores lastPlotData (the most recent data received from the simulation) protected by a plotMutex for safe access from different goroutines, and the current plot dimensions (plotWidth, plotHeight).

createMainWindow:

    Initializes the AppUI struct.

    Creates all the widgets (widget.Label, widget.Slider, widget.Button, canvas.Raster).

    Sets up widget callbacks:

        Slider's OnChanged updates its label and sends an "update_g" command via controlChan.

        Buttons send "start", "stop", or "reset" commands via controlChan. The reset button also updates the GUI immediately.

    Plotting: Uses canvas.NewRaster which takes a generator function (ui.drawDensity, ui.drawPhase) as an argument. This function will be called by Fyne whenever the raster needs to be redrawn (e.g., after raster.Refresh() is called).

    Interaction: Wraps the densityPlot using the custom TappableRaster widget to capture mouse click/tap (handlePlotTap) and hover (handlePlotHover) events.

    Layout: Uses Fyne layout containers (VBox, HBox, Border, Grid, Stack) to arrange the widgets in the desired structure (plots side-by-side, controls below). Stack is used to overlay titles on the plot areas.

    Launches the guiUpdateLoop in a goroutine.

    Sets the window size and returns the ui struct.

guiUpdateLoop:

    Runs continuously in a separate goroutine.

    Ranges over the updateChan, blocking until data arrives or the channel is closed.

    If an error is received in PlotData, it shows an error dialog.

    If valid plot data is received:

        It schedules the UI update logic to run on Fyne's main goroutine using ui.Window.RunOnMain. This is essential for thread safety with the GUI toolkit.

        Inside RunOnMain: It locks ui.plotMutex, updates ui.lastPlotData, unlocks the mutex, updates the ui.timeLabel, and calls Refresh() on both raster plots (ui.densityPlot, ui.phasePlot). Refreshing triggers the drawDensity and drawPhase functions.

drawDensity/drawPhase:

    These are the raster generator functions.

    They lock the plotMutex to safely access ui.lastPlotData.

    They create a new image.RGBA for the current raster size (w, h).

    They determine color scaling (finding max density, normalizing phase).

    They loop through the pixels (x, y) of the image.

    They map the pixel coordinates to the corresponding data array indices (r, c) of the (transposed) DensitySlice or PhaseSlice.

    They retrieve the data value, handle NaN/Inf, normalize it, and use a colormap function (viridis, hsv) to get a color.Color.

    They set the pixel color using img.Set(x, y, color).

    They return the generated image.Image.

Colormaps (viridis, hsv): Simple functions mapping a normalized value [0, 1] to a color. (Implementations copied from the previous example).

handlePlotTap:

    Callback for clicks on the density plot.

    Gets the plot extent from lastPlotData.

    Maps the click's pixel coordinates (pos.X, pos.Y) to simulation coordinates (simX, simY).

    Shows a dialog.ShowForm to prompt the user for the vortex charge.

    If the user confirms, it sends an "imprint" command with the coordinates and charge via controlChan.

handlePlotHover:

    Callback for mouse movement over the density plot.

    Maps pixel coordinates to simulation coordinates.

    Updates the ui.coordLabel text. Clears the label if the mouse exits (exited is true).
